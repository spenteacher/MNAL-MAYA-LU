\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{geometry}
\usepackage{float}
\usepackage{enumitem}
\usepackage{biblatex}
\usepackage{xcolor}
\addbibresource{referencias_completo.bib}
\geometry{margin=2.5cm}

\newtheorem{theorem}{Teorema}[section]
\newtheorem{lemma}[theorem]{Lema}
\newtheorem{proposition}[theorem]{Proposición}
\newtheorem{corollary}[theorem]{Corolario}
\newtheorem{definition}{Definición}[section]
\newtheorem{example}{Ejemplo}[section]
\newtheorem{remark}{Observación}[section]
\newtheorem{notation}{Notación}[section]

\theoremstyle{definition}
\newtheorem{algoritmo}{Algoritmo}[section]

\newcommand{\matn}{\mathbb{R}^n}
\newcommand{\matnn}{\mathbb{R}^{n \times n}}

\title{\textbf{Descomposición LU en Simulación Computacional:} \\
Fundamentos Teóricos y Aplicación a Sistemas de Partículas}
\author{Zaragoza Pastor, Samuel \\Hernández Barrero, Jose\\Liu, Biyi \\Fernández García, Aquilas\\Botella Guillén, Pau}

\begin{document}

\maketitle

\begin{abstract}
Este trabajo desarrolla en profundidad los fundamentos matemáticos de la descomposición LU y su aplicación a la resolución eficiente de sistemas lineales. Se presenta una demostración rigurosa de existencia y unicidad, análisis de complejidad computacional, y una aplicación práctica al modelado de sistemas de partículas conectadas por resortes.
\end{abstract}

\tableofcontents
\newpage

\section{Introducción}

\subsection{Motivación}

La resolución de sistemas lineales \(Ax = b\) es una operación fundamental en álgebra lineal computacional. Cuando es necesario resolver múltiples sistemas con la misma matriz \(A\) pero diferentes vectores \(b\), surge naturalmente la pregunta: ¿podemos aprovechar cálculos previos para acelerar las resoluciones subsecuentes?

La descomposición LU responde afirmativamente a esta cuestión, separando el problema en dos fases:
\begin{enumerate}
\item \textbf{Factorización} (costosa, una sola vez): \(A = LU\)
\item \textbf{Resolución} (económica, múltiples veces): Resolver \(Ly = b\) y \(Ux = y\)
\end{enumerate}

Este trabajo explora los fundamentos teóricos de esta descomposición y demuestra su utilidad práctica mediante un simulador de partículas donde el mismo sistema lineal debe resolverse repetidamente.

\subsection{Estructura del Documento}

\begin{itemize}
\item \textbf{Sección 2}: Teoría matemática de la descomposición LU con demostraciones completas
\item \textbf{Sección 3}: Análisis de complejidad computacional
\item \textbf{Sección 4}: Modelado matemático del sistema de partículas
\item \textbf{Sección 5}: Formulación matricial del problema físico
\item \textbf{Sección 6}: Implementación y resultados experimentales
\item \textbf{Sección 7}: Conclusiones y extensiones
\end{itemize}

\section{Fundamentos Teóricos de la Descomposición LU \cite{golub2013matrix} \cite{trefethen1997numerical}}

\begin{notation}
    Las entradas de una matriz \(A\) las denotaremos con la misma letra en minúscula y con subíndices indicando la entrada, es decir, \(a_{ij}\) sería la entrada \(i,j\)-ésima de la matriz \(A\).
\end{notation}

\subsection{Definiciones Básicas \cite{metodosNumericos}}

\begin{definition}[Matriz Triangular Inferior]
Una matriz \(L \in \matnn\) es \textbf{triangular inferior} si \(l_{ij} = 0\) para todo \(i < j\). Es \textbf{triangular inferior unitaria} si además \(l_{ii} = 1\) para todo \(i = 1, \ldots, n\).
\end{definition}

\begin{definition}[Matriz Triangular Superior]
Una matriz \(U \in \matnn\) es \textbf{triangular superior} si \(u_{ij} = 0\) para todo \(i > j\).
\end{definition}

\begin{definition}[Descomposición LU]
Sea \(A \in \matnn\). Una \textbf{descomposición LU} de \(A\) es una factorización:
\[
A = LU
\]
donde \(L\) es triangular inferior unitaria y \(U\) es triangular superior.
\end{definition}

\begin{definition}[Matriz semidefinida positiva]
	Una matriz \(A \in \matnn\) es una \textbf{matriz semidefinida positiva} si \(\forall x \in \matn \setminus\{0\}, x^tAx\geq0\).
\end{definition}

\begin{definition}[Matriz definida positiva]
	Una matriz \(A \in \matnn\) es una \textbf{matriz definida positiva} si \(\forall x \in \matn \setminus\{0\}, x^tAx > 0. \)
\end{definition}

\subsection{Descomposición LU \cite{libretextsLU} \cite{wikipediaLU}}

Sea \(A^{(0)} = A\in \matnn\), denotaremos al multiplicador \(i,j\)-ésimo como \(\alpha_{i,j}=-\frac{a_{ij}^{(j-1)}}{a_{jj}^{(j-1)}}\). Basándose en la descomposición gaussiana, el algoritmo de la descomposición LU consiste en:
\begin{enumerate}
    \item En el paso \(k\), partiendo de la matriz \(A^{(k)}\), aplicamos transformaciones elementales para hacer cero todos los elementos por debajo de la diagonal principal en la columna \(k\).
    \item Definimos la matriz \(M_k\) como la matriz que recoge las transformaciones elementales del paso \(k\) de tal manera que \(A^{(k)}=M_kA^{(k-1)}\).
\end{enumerate}
Este algoritmo se repetirá hasta el paso \(n-1\), donde obtendríamos que \(A^{(n-1)}=U\).

Por otro lado, \(L\) lo obtenemos de:
\[
I-\sum_{k=1}^{n-1}v^{(k)}e_k^T
\]
donde \(v^{(k)}\) viene dado por
\[
\sum_{j=k+1}^n \alpha_{j,k}e_j
\]
y \(e_j\) y \(e_k\) son los vectores de la base canónica de \(\matn\).

\begin{remark}
    Es importante notar que si durante una iteración de la eliminación gaussiana existe algún pivote nulo, el algoritmo anterior se interrumpiría (pues \(a_{ii}^{(k)}=0\). Para evitar este caso, utilizaremos la descomposición LU con pivoteo, la cual, si se cumple ciertas hipótesis, podemos obtener una descomposición similar a la LU.
\end{remark}

\subsection{Descomposición LU con Pivoteo Parcial \cite{watkins2010fundamentals}}

Para garantizar la existencia de la descomposición para cualquier matriz invertible , se introduce el pivoteo.

\begin{definition}[Matriz de Permutación]
Una matriz \(P \in \matnn\) es una \textbf{matriz de permutación} si cada fila y cada columna contiene exactamente un 1 y los demás elementos son 0.
\end{definition}

\begin{theorem}[Descomposición LU con Pivoteo]
Para toda matriz invertible \(A \in \matnn\), existe una matriz de permutación \(P\) tal que:
\[
PA = LU
\]
donde \(L\) es triangular inferior unitaria y \(U\) es triangular superior.
\end{theorem}

\begin{proof}[Idea de la demostración]
El algoritmo de eliminación gaussiana con pivoteo parcial consiste en:
\begin{enumerate}
\item En el paso \(k\), buscar el elemento de mayor valor absoluto en la columna \(k\), desde la fila \(k\) hasta \(n\).
\item Intercambiar la fila con el pivote máximo con la fila \(k\).
\item Aplicar eliminación gaussiana.
\end{enumerate}

Los intercambios de filas se acumulan en la matriz de permutación \(P\). El pivoteo garantiza estabilidad numérica evitando dividir entre 0 o números muy pequeños.
\end{proof}

\section{Análisis de Complejidad Computacional \cite{burden2015numerical} }

\subsection{Complejidad de la Factorización LU}

\begin{proposition}[Coste de la Factorización]
El número de operaciones aritméticas (multiplicaciones y sumas) necesarias para factorizar una matriz \(A \in \matnn\) mediante descomposición LU es:
\[
T_{fact}(n) = \frac{2n^3}{3} + O(n^2)
\]
\end{proposition}

\begin{proof}
En el paso \(k\) de la eliminación gaussiana (\(k = 1, \ldots, n-1\)):
\begin{itemize}
\item Se calculan \((n-k)\) multiplicadores: \(\alpha_{ik} = -a_{ik}^{(j-1)}/a_{kk}^{(j-1)}\) para \(i = k+1, \ldots, n\)
\item Se calculan \(2(n-k)^2\) operaciones para la matriz de trabajo (2 operaciones/elemento).
\[
a_{ij} \leftarrow a_{ij} - \alpha_{ik} \cdot a_{kj} \quad \text{para } j = k+1, \ldots, n
\]
\end{itemize}

El número total de multiplicaciones es:
\[
M = \sum_{k=1}^{n-1} (n-k) + \sum_{k=1}^{n-1} 2(n-k)^2 = \sum_{j=1}^{n-1} j + \sum_{j=1}^{n-1} 2j^2
\]

Usando las fórmulas:
\begin{align*}
\sum_{j=1}^{n-1} j &= \frac{(n-1)n}{2} \\
\sum_{j=1}^{n-1} j^2 &= \frac{(n-1)n(2n-1)}{6}
\end{align*}

Obtenemos:
\[
M = \frac{(n-1)n}{2} + 2\frac{(n-1)n(2n-1)}{6} = \frac{4n^3 -3n^2 - n}{6} = \frac{2n^3}{6} - \frac{n^2}{2} - \frac{n}{6}
\]

Por tanto, tenemos que \(T_{fact}(n) = \frac{2n^3}{3} + O(n^2)\).
\end{proof}

\subsection{Complejidad de la Resolución}

\begin{proposition}[Coste de Sustitución Triangular]
Resolver un sistema triangular de orden \(n\) requiere:
\[
T_{subst}(n) = n^2
\]
operaciones.
\end{proposition}

\begin{proof}
\textbf{Sustitución progresiva} (\(Ly = b\)):
\[
y_i = \frac{1}{l_{ii}}(b_i - \sum_{j=1}^{i-1} l_{ij}y_j) \quad \text{para } i = 1, \ldots, n
\]
Operaciones por fila:
\begin{itemize}
    \item En el sumatorio: \((i-1)\) multiplicaciones \(i-2\) sumas
    \item Fuera del sumatorio: \(2\) sumas
\end{itemize}
Total:
\[
\sum_{i=1}^{n} (2i-1) = 2\sum_{j=0}^{n}j - n = 2\frac{n(n+1)}{2}-n = n^2
\]

\textbf{Sustitución regresiva} (\(Ux = y\)): Análogo, \(n^2\) operaciones.
\end{proof}

\subsection{ \color{red}Comparación LU vs Eliminación Gaussiana \cite{strang2016introduction} \cite{libretextsGauss}}

\begin{theorem}[Ventaja Computacional de LU]
Para resolver \(m\) sistemas lineales \(Ax^{(k)} = b^{(k)}\), \(k = 1, \ldots, m\), con la misma matriz \(A\):

\begin{itemize}
\item \textbf{Descomposición LU}:
\[
T_{LU}(n,m) = \frac{2n^3}{3} - \frac{n^2}{2} - \frac{n}{6} +  m \cdot 2n^2 \approx  \frac{2n^3}{3} + m \cdot 2n^2 + O(n^2)
\]

\item \textbf{Eliminación Gaussiana repetida}:
\[
T_{Gauss}(n,m) = m(\frac{2n^3}{3} - \frac{n^2}{2} - \frac{n}{6} +n^2) \approx m \cdot \frac{2n^3}{3} + O(mn^2)
\]
\end{itemize}

El \textbf{speedup} es:
\[
S(n,m) = \frac{T_{Gauss}}{T_{LU}} = \frac{m(\frac{2n^3}{3} - \frac{n^2}{2} - \frac{n}{6} +n^2)}{\frac{2n^3}{3} - \frac{n^2}{2} - \frac{n}{6} +  m \cdot 2n^2} \approx \frac{m}{1 + \frac{3m}{n}}
\]
\end{theorem}

\begin{proof}
La descomposición LU factoriza \(A\) una sola vez, luego resuelve \(m\) veces mediante sustitución. La eliminación gaussiana repite la factorización \(m\) veces.
\end{proof}

\begin{corollary}
Para \(m\) suficientemente grande y \(n\) fijo:
\[
\lim_{m \to \infty} S(n,m) = \frac{n}{3}
\]

En simulaciones a 60 fps durante 1 segundo (\(m = 60\)) con \(n = 50\):
\[
S(50, 60) = \frac{60}{1 + \frac{180}{50}} = \frac{60}{1 + 3.6} \approx 13.04
\]

\end{corollary}

\section{\color{red} Modelado Matemático del Sistema Físico \cite{hibbeler2016engineering} \cite{serway2014physics}}

\subsection{Descripción del Sistema}

Consideramos un sistema de \(N\) partículas puntuales en el plano \(\mathbb{R}^2\):
\begin{itemize}
\item Posición de la partícula \(i\): \(\vec{r}_i = (x_i, y_i)^T \in \mathbb{R}^2\)
\item Masa: \(m_i > 0\)
\item Conexiones elásticas (resortes) entre pares de partículas
\item Condiciones de frontera: Algunas partículas están fijas en el espacio
\end{itemize}

\subsection{Fuerzas en el Sistema}

\subsubsection{Fuerza Gravitatoria}

La gravedad actúa verticalmente hacia abajo:
\[
\vec{F}_i^{grav} = m_i \vec{g} = m_i \begin{pmatrix} 0 \\ g \end{pmatrix}
\]
donde \(g > 0\) es la aceleración gravitacional.

\subsubsection{Fuerza de Resorte (Ley de Hooke)}

Para un resorte entre partículas \(i\) y \(j\):

\begin{definition}[Fuerza de Hooke Vectorial \cite{libretextsHooke} ]
\[
\vec{F}_{ij} = k_{ij} \left( |\vec{r}_j - \vec{r}_i| - L_{ij}^0 \right) \hat{e}_{ij}
\]
donde:
\begin{itemize}
\item \(k_{ij} > 0\): Constante elástica del resorte
\item \(L_{ij}^0 > 0\): Longitud natural del resorte
\item \(|\vec{r}_j - \vec{r}_i|\): Distancia actual entre partículas
\item \(\hat{e}_{ij} = \frac{\vec{r}_j - \vec{r}_i}{|\vec{r}_j - \vec{r}_i|}\): Vector unitario de \(i\) hacia \(j\)
\end{itemize}
\end{definition}

\begin{remark}
La fuerza \(\vec{F}_{ij}\) actúa sobre la partícula \(i\) en dirección \(i \to j\). Por la tercera ley de Newton:
\[
\vec{F}_{ji} = -\vec{F}_{ij}
\]
\end{remark}

\subsection{Condición de Equilibrio Estático \cite{beer2013mecanica}}

\begin{definition}[Equilibrio Estático]
Un sistema de partículas está en \textbf{equilibrio estático} si la fuerza total sobre cada partícula libre es nula:
\[
\vec{F}_i^{grav} + \sum_{j \in \mathcal{N}(i)} \vec{F}_{ij} = \vec{0} \quad \forall i \text{ libre}
\]
donde \(\mathcal{N}(i)\) es el conjunto de partículas conectadas a \(i\).
\end{definition}

Este enfoque evita resolver ecuaciones diferenciales temporales, buscando directamente la configuración de equilibrio.

\subsection{Linealización de las Fuerzas}

\begin{proposition}[Aproximación Lineal de Hooke]
Para pequeñas deformaciones alrededor de posiciones de reposo \(\vec{r}_i^0\), la fuerza de resorte se puede aproximar linealmente:
\[
\vec{F}_{ij} \approx k_{ij} \left[ (\vec{r}_j - \vec{r}_i) - (\vec{r}_j^0 - \vec{r}_i^0) \right]
\]
\end{proposition}

\begin{proof}
Sea \(\vec{\delta}_i = \vec{r}_i - \vec{r}_i^0\) el desplazamiento desde la posición de reposo. Entonces:
\[
|\vec{r}_j - \vec{r}_i| = |(\vec{r}_j^0 - \vec{r}_i^0) + (\vec{\delta}_j - \vec{\delta}_i)|
\]

Para \(|\vec{\delta}_j - \vec{\delta}_i| \ll L_{ij}^0\), expandimos:
\[
|\vec{r}_j - \vec{r}_i| \approx L_{ij}^0 + \frac{(\vec{r}_j^0 - \vec{r}_i^0) \cdot (\vec{\delta}_j - \vec{\delta}_i)}{L_{ij}^0}
\]

Sustituyendo en la ley de Hooke y simplificando, obtenemos la aproximación lineal.
\end{proof}

\section{\color{red} Formulación Matricial del Problema \cite{cook2007concepts}}

\subsection{Construcción de la Matriz de Rigidez}

\begin{definition}[Matriz de Rigidez \cite{wikipediaRigidez}]
Para un sistema con \(n\) partículas libres, la \textbf{matriz de rigidez} \(K \in \matnn\) se define elemento a elemento como:
\[
K_{ij} = \begin{cases}
\displaystyle \sum_{m \in \mathcal{N}(i)} k_{im} & \text{si } i = j \\[10pt]
-k_{ij} & \text{si existe resorte entre } i \text{ y } j \\[10pt]
0 & \text{en otro caso}
\end{cases}
\]
\end{definition}

\begin{remark}
	En nuestro proyecto y y programa en la práctica se aproxima la matriz de Rigidez a una matriz de un sistema unidimensional, luego podemos asociar una componente en función de la otra.
\end{remark}

\begin{theorem}[Propiedades de la Matriz de Rigidez]
La matriz \(K\) satisface:
\begin{enumerate}
\item \textbf{Simetría}: \(K = K^T\)
\item \textbf{Definida positiva}: Si hay al menos una partícula fija, \(K\) es definida positiva
\end{enumerate}
\end{theorem}

\begin{proof}
	
\textbf{(1) Simetría}: Por construcción, si existe resorte entre \(i\) y \(j\), entonces \(K_{ij} = K_{ji} = -k_{ij}\).

\textbf{(2) Definida positividad}: Consideremos la energía potencial elástica total:
\[
V(\vec{x}) = \frac{1}{2} \sum_{\text{resortes } ij} k_{ij} (|\vec{r}_j - \vec{r}_i| - L_{ij}^0)^2
\]

En la aproximación lineal:
\[
V \approx \frac{1}{2} \vec{x}^T K \vec{x} + \text{constante}
\]

Como \(V \geq 0\) y alcanza el mínimo solo en el equilibrio, \(K\) debe ser semidefinida positiva. La presencia de partículas fijas elimina los modos rígidos (traslaciones), haciendo \(K\) definida positiva.

\end{proof}

\subsection{Vector de Fuerzas}

\begin{definition}[Vector de Términos Independientes]
El vector \(\vec{f} \in \mathbb{R}^n\) se construye como:
\[
\vec{f} = K \vec{x}^0 + \vec{F}^{ext}
\]
donde:
\begin{itemize}
\item \(\vec{x}^0\): Vector de posiciones de reposo
\item \(\vec{F}^{ext}\): Fuerzas externas (gravedad)
\end{itemize}
\end{definition}

\subsection{Sistema Lineal Final}

\begin{theorem}[Formulación del Equilibrio como Sistema Lineal]
Las posiciones de equilibrio \(\vec{x}_{eq}\) del sistema satisfacen:
\[
K \vec{x}_{eq} = \vec{F}^{ext}
\]
Este sistema se resuelve independientemente para cada coordenada espacial.
\end{theorem}

\begin{proof}
Por la condición de equilibrio y la linealización:
\[
\sum_{j \in \mathcal{N}(i)} k_{ij} [(\vec{r}_j - \vec{r}_i) - (\vec{r}_j^0 - \vec{r}_i^0)] + \vec{F}_i^{ext} = \vec{0}
\]

Reorganizando:
\[
\sum_{j \in \mathcal{N}(i)} k_{ij} (\vec{r}_j - \vec{r}_i) = \sum_{j \in \mathcal{N}(i)} k_{ij} (\vec{r}_j^0 - \vec{r}_i^0) + \vec{F}_i^{ext}
\]

Esta es precisamente la fila \(i\) del sistema \(K\vec{x} = \vec{F}^{ext}\).
\end{proof}

\section{ \color{green} Implementación Computacional \cite{numpyDoc} \cite{scipyLU} \cite{matplotlibDoc}}

\subsection{Algoritmo de Descomposición LU}

\begin{algorithm}[H]
\caption{Descomposición LU con Pivoteo Parcial}
\begin{algorithmic}[1]
\REQUIRE \(A \in \matnn\) invertible
\ENSURE \(L, U, P\) tales que \(PA = LU\)
\STATE \(L \leftarrow I_n\), \(U \leftarrow A\), \(P \leftarrow I_n\)
\FOR{\(k = 1\) \TO \(n-1\)}
    \STATE \(i^* \leftarrow \arg\max_{i \geq k} |u_{ik}|\) \COMMENT{Buscar pivote}
    \IF{\(i^* \neq k\)}
        \STATE Intercambiar filas \(k\) e \(i^*\) en \(U\) y \(P\)
        \STATE Intercambiar \(l_{k,1:k-1}\) y \(l_{i^*,1:k-1}\) en \(L\)
    \ENDIF
    \FOR{\(i = k+1\) \TO \(n\)}
        \STATE \(l_{ik} \leftarrow u_{ik}/u_{kk}\)
        \STATE \(u_{i,k:n} \leftarrow u_{i,k:n} - l_{ik} \cdot u_{k,k:n}\)
    \ENDFOR
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsection{Algoritmo de Simulación}

\begin{algorithm}[H]
\caption{Actualización del Sistema por Frame}
\begin{algorithmic}[1]
\REQUIRE Posiciones actuales, topología del sistema
\ENSURE Nuevas posiciones de equilibrio
\STATE Construir matriz \(K\) de rigidez
\STATE Construir vector \(\vec{f}\) de fuerzas
\IF{Primera iteración o topología cambió}
    \IF{Método LU}
        \STATE Calcular \(PA = LU\) \COMMENT{\(O(n^3)\) una sola vez}
    \ENDIF
\ENDIF
\STATE Resolver \(K\vec{x} = \vec{f}\):
\IF{Método LU}
    \STATE Resolver \(Ly = Pf\) \COMMENT{Sustitución progresiva \(O(n^2)\)}
    \STATE Resolver \(Ux = y\) \COMMENT{Sustitución regresiva \(O(n^2)\)}
\ELSE
    \STATE Aplicar eliminación gaussiana completa \COMMENT{\(O(n^3)\)}
\ENDIF
\STATE Actualizar posiciones con suavizado: \(\vec{r}_i \leftarrow (1-\alpha)\vec{r}_i + \alpha \vec{x}_i\)
\end{algorithmic}
\end{algorithm}

\subsection{Estructura del Código}

El proyecto consta de tres módulos principales:

\begin{enumerate}
\item \texttt{lu\_solver.py}: Implementación de descomposición LU y eliminación gaussiana
\begin{itemize}
\item Clase \texttt{LUSolver}: Factorización \(PA = LU\) con pivoteo
\item Clase \texttt{GaussianSolver}: Eliminación gaussiana directa
\item Funciones de benchmark
\end{itemize}

\item \texttt{physics\_simple.py}: Sistema de partículas y resortes
\begin{itemize}
\item Clase \texttt{Particle}: Representa una partícula
\item Clase \texttt{Spring}: Representa un resorte
\item Clase \texttt{EquilibriumSystem}: Construye \(K\), \(\vec{f}\) y resuelve
\end{itemize}

\item \texttt{main\_simple.py}: Visualización con Pygame
\begin{itemize}
\item Renderizado de partículas y resortes
\item Comparación visual lado a lado: LU vs Gauss
\item Estadísticas de rendimiento en tiempo real
\end{itemize}
\end{enumerate}

\section{\color{green} Resultados Experimentales \cite{zienkiewicz2013finite}}

\subsection{Configuración de Pruebas}

Se ejecutaron benchmarks con matrices de diferentes tamaños, resolviendo 100 sistemas con la misma matriz \(K\) pero diferentes vectores \(\vec{f}\).

\begin{table}[H]
	\centering
	
	\begin{tabular}{ccccccc}
		\hline
		\textbf{Tamaño} & \textbf{LU Decomp (ms)} & \textbf{LU Solve (ms)} & \textbf{LU Total (ms)} & \textbf{Gauss (ms)} & \textbf{Speedup} \\ 
		\hline
		10x10  & 0.22  & 0.039 & 4.07  & 19.01   & 4.66x  \\
		20x20  & 0.61  & 0.085 & 9.11  & 56.58   & 6.21x  \\
		30x30  & 1.14  & 0.104 & 11.52 & 114.23  & 9.92x  \\
		50x50  & 4.39  & 0.149 & 19.28 & 306.89  & 15.92x \\
		100x100 & 12.95 & 0.299 & 42.88 & 1220.97 & 28.48x \\
		\hline
	\end{tabular}
	\caption{Comparación de tiempos entre métodos LU y Gauss}
	\label{tab:lu_vs_gauss}
\end{table}

\subsection{Análisis de Resultados}

\begin{enumerate}
\item \textbf{Verificación de complejidad}: Los tiempos crecen como \(O(n^3)\) para la factorización y \(O(n^2)\) para cada resolución, confirmando el análisis teórico.

\textbf{\textit{Nótese:}} Estos resultados son usando nuestra subrutina de Benchmark. Es decir que no se han realizado con mallas de tales tallas por no hacer más complicada la implementación del programa gráfica

\item \textbf{Speedup creciente}: El speedup aumenta con \(n\), alcanzando 28,48x para \(n = 100\). Esto se debe a que el término \(O(n^3)\) de la factorización se amortiza mejor para sistemas grandes.

\item \textbf{Predicción teórica vs experimental}: Para \(n = 100\), \(m = 100\):
\[
 \textbf{teorico} = \frac{100}{1 + \frac{300}{100}} = \frac{100}{7} = 25 \approx 28,48
\]

El valor experimental varía respecto del teorico
\begin{itemize}
\item Overheads de gestión de memoria
\item Construcción de la matriz \(K\) (no contabilizada en el análisis teórico)
\item Operaciones de punto flotante de bajo nivel
\item Optimizaciones del cálculo de matrices por parte de Numpy
\end{itemize}


\end{enumerate}


\newpage

\section{Referencias}

\printbibliography

\end{document}
